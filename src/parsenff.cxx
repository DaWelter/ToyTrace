#include "scene.hxx"
#include "camera.hxx"
#include "infiniteplane.hxx"
#include "shader.hxx"
#include "util.hxx"
#include "atmosphere.hxx"
#include "light.hxx"
#include "parse_common.hxx"

// To whomever dares to read this code!
// I know what this looks like. 
// I'm making a half way sensible yaml-based scene parser. parse_yaml_scene.cxx.
// It will replace this garbage.


#define LINESIZE 1000

#ifdef _MSC_VER
// Warnings generated by yaml-cpp. Hopefully they are harmless. They don't look like it ... :-/
#pragma warning (disable: 4251)
#pragma warning (disable: 4373)
#pragma warning (disable: 4275)
#endif

#include <yaml-cpp/yaml.h>

using namespace RadianceOrImportance;
using namespace scenereader;

using util::startswith;
using util::endswith;



Material MakeMaterialFromActiveThings(const Scope &scope)
{
  return { scope.shaders(), scope.mediums(), scope.areaemitters() };
}


void AddNamedMaterialFromActiveThings(const std::string &name, Scope &scope)
{
  scope.materials[name] = MakeMaterialFromActiveThings(scope);
}


Material GetMaterial(Scope &scope, std::optional<std::string> name)
{
  if (name)
  {
    std::cout << "Lookup material " << *name << ", ";

    if (*name != "DefaultMaterial") // A Cinema4D thing
    {
      if (auto it = scope.materials.find(*name); it != scope.materials.end())
      {
        std::cout << " found. Emitter = " << (void*)(it->second.emitter) << "\n";
        return it->second;
      }
      else
      {
        std::cout << " found a shader\n";
        scope.shaders.activate(*name);
        return MakeMaterialFromActiveThings(scope);
      }
    }
    else
      std::cout << " ... not found\n";
  }
  return MakeMaterialFromActiveThings(scope);
}


class NFFParser : public GlobalContext
{
  std::string line;
  bool        line_stream_state;
  std::string peek_line;
  bool        peek_stream_state;
  std::istream &input;
  int lineno;
public:
  NFFParser(
      Scene* _scene,
      RenderingParameters *_render_params,
      std::istream &_is,
      const fs::path &_path_hint) :
    GlobalContext{*_scene, _render_params, _path_hint},
    input{_is},
    lineno{0}
  {
    line_stream_state = true;
    peek_stream_state = (bool)std::getline(input, peek_line);
  }

  void Parse(Scope &scope);
  void ParseYaml(const std::string &yaml_section, Scope &scope);
  void ParseYamlNode(const std::string &key, const YAML::Node &node, Scope &scope);
private:
  void ParseMesh(const fs::path &filename, Scope &scope);
  //MaterialIndex GetMaterialIndexOfCurrentParams(const Scope &scope);
  //MaterialIndex MaterialInsertAndOrGetIndex(const Material &m);
  //void AddModel(const Mesh &m, const Scope &scope);
  void InsertAndActivate(const char*, Scope &scope, std::unique_ptr<Medium> x);
  void InsertAndActivate(const char*, Scope &scope, std::unique_ptr<Shader> x);
  bool NextLine();
  std::runtime_error MakeException(const std::string &msg) const;
  fs::path MakeFullPath(const fs::path &filename) const;
  void AddPointLight(std::unique_ptr<RadianceOrImportance::PointEmitter> p);
};


void NFFParser::Parse(Scope &scope)
{
  using namespace materials;

  char token[LINESIZE+1];
  while (NextLine())
  {
    if (line.empty())
      continue;
    
    if (line[0] == '#') // '#' : comment
      continue;
    
    // TODO: streams: https://stackoverflow.com/questions/1033207/what-should-i-use-instead-of-sscanf
    int numtokens = sscanf(line.c_str(),"%s",token);
    if (numtokens <= 0) // empty line, except for whitespaces
      continue; 
    
    
    if (!strcmp(token,"{")) {
      Scope child{scope};
      Parse(child);
      continue;
    }

    
    if (!strcmp(token,"}")) {
      break;
    }
    
    if (!strcmp(token,"yaml{")) {
      std::string yaml_section; 
      yaml_section.reserve(1024);
      bool properly_terminated = false;
      while (NextLine() && !(properly_terminated = startswith(line, "}yaml")))
      {
        yaml_section.append(line);
        yaml_section.append("\n"); // Newline was removed from the line. Put it back in.
      }
      if (!properly_terminated)
        throw MakeException("Error. Yaml section was not terminated with }yaml token.");
      if (!yaml_section.empty())
      {
        yaml_section.pop_back(); // Don't need the last newline.
        ParseYaml(yaml_section, scope);
      }
      continue;
    }
    
    if (!strcmp(token, "transform"))
    {
      Double3 t, r, s;
      int n;
      n = std::sscanf(line.c_str(),"transform %lg %lg %lg %lg %lg %lg %lg %lg %lg\n",&t[0], &t[1], &t[2], &r[0], &r[1], &r[2], &s[0], &s[1], &s[2]);
      if (n == EOF) n = 0; // Number of arguments is actually zero.
      else if (n == 0) n = -1; // Failure.
      if (n !=0 && n != 3 && n != 6 && n != 9)
        throw MakeException("Bad number of arguments to transform directive");
      decltype(scope.currentTransform) trafo;
      if (n == 0)
      {
        trafo = decltype(trafo)::Identity();
      }
      if (n >= 3)
      {
        trafo = Eigen::Translation3d(t);
      }
      if (n >= 6)
      {
        // The heading, pitch, bank convention assuming Y is up and Z is forward!
        trafo = trafo *
          Eigen::AngleAxisd(r[0], Eigen::Vector3d::UnitY()) *
          Eigen::AngleAxisd(r[1], Eigen::Vector3d::UnitX()) *
          Eigen::AngleAxisd(r[2], Eigen::Vector3d::UnitZ());
        if (n >= 9)
        {
          trafo = trafo * Eigen::Scaling(s);
        }
      }
      scope.currentTransform = trafo;
      std::cout << "Transform: t=\n" << scope.currentTransform.translation() << "\nr=\n" << scope.currentTransform.linear() << std::endl;
      continue;
    }
    
    /* camera */
    
    struct CommonCameraData
    {
      Double3 pos{NaN}, at{NaN}, up{NaN};
      int resX{-1}, resY{-1};
    };
    
    auto ParseCameraData = [this]() -> CommonCameraData
    {
      CommonCameraData cd;
      bool ok;
      ok = 3 == std::sscanf(line.c_str(),"from %lg %lg %lg\n",&cd.pos[0],&cd.pos[1],&cd.pos[2]);
      if (!ok) throw MakeException("Error");
      NextLine();
      ok = 3 == std::sscanf(line.c_str(),"at %lg %lg %lg\n",&cd.at[0],&cd.at[1],&cd.at[2]);
      if (!ok) throw MakeException("Error");
      NextLine();
      ok = 3 == std::sscanf(line.c_str(),"up %lg %lg %lg\n",&cd.up[0],&cd.up[1],&cd.up[2]);
      if (!ok) throw MakeException("Error");
      NextLine();
      ok = 2 == std::sscanf(line.c_str(),"resolution %d %d\n",&cd.resX,&cd.resY);
      if (!ok) throw MakeException("Error");
      NextLine();
      return cd;
    };
    
    auto MakeConsistentResolutionSettings = [this](CommonCameraData &cd)
    {
      if (auto render_params = GetParams(); render_params != nullptr)
      {
        if (render_params->height > 0)
          cd.resY = render_params->height;
        else
          render_params->height = cd.resY;
        if (render_params->width > 0)
          cd.resX = render_params->width;
        else
          render_params->width = cd.resX;
      }
    };
    
    if (!strcmp(token, "vfisheye"))
    {
      NextLine();
      auto cd = ParseCameraData();
      MakeConsistentResolutionSettings(cd);
      GetScene().camera = std::make_unique<FisheyeHemisphereCamera>(cd.pos,cd.at-cd.pos,cd.up,cd.resX,cd.resY);
      continue;
    }
    
    if (!strcmp(token,"v"))
    {
      // FORMAT:
      //     v
      //     from %lg %lg %lg
      //     at %lg %lg %lg
      //     up %lg %lg %lg
      //     resolution %d %d
      //     angle %lg
      double angle{NaN};
      NextLine();
      auto cd = ParseCameraData();
      MakeConsistentResolutionSettings(cd);
      if (1 != std::sscanf(line.c_str(),"angle %lg\n",&angle)) 
        throw MakeException("Error");
      NextLine();
      GetScene().camera = std::make_unique<PerspectiveCamera>(cd.pos,cd.at-cd.pos,cd.up,angle,cd.resX,cd.resY);
      continue;
    }
    
    /* sphere */

    if (!strcmp(token,"s"))
    {
      Double3 pos;
      double rad;
      int n = sscanf(line.c_str(),"s %lg %lg %lg %lg",&pos[0],&pos[1],&pos[2],&rad);
      if (n == 4)
      {
          pos = scope.currentTransform*pos;
          auto  sphere = Spheres();
          sphere.Append(pos.cast<float>(), rad);
          GetScene().Append(sphere, MakeMaterialFromActiveThings(scope));
      }
      else throw MakeException("Error");
      continue;
    }

    /* polygon (with normals and uv) */
    if (!strcmp(token,"p")) 
    {
      int num_vertices;
      sscanf(line.c_str(),"p %d",&num_vertices);
      
      if (num_vertices < 3)
        throw MakeException("Polygon must be specified with at least 3 vertices");
      
      auto mesh = Mesh(num_vertices-2, num_vertices);
      bool must_compute_normal = false;
      
      for (int i=0;i<num_vertices;i++)
      {
        Double3 v{0.};
        Double3 n{0.};
        Double2 uv{0.};
        if (!NextLine())
          throw MakeException("Cannot read specified number of vertices");
        int n_read = sscanf(line.c_str(),"%lg %lg %lg %lg %lg %lg %lg %lg\n", 
                            &v[0],&v[1],&v[2], &n[0],&n[1],&n[2], &uv[0],&uv[1]);
        if (n_read < 3)
          throw MakeException("Cannot vertex coordinates");
        
        // Compute normals from vertices if one vertex has no or invalid normal specification.
        must_compute_normal |= (n_read < 6);
        v = scope.currentTransform * v;
        n = Normalized(NormalTrafo(scope.currentTransform)*n);
        mesh.vertices.row(i) = v.cast<float>();
        mesh.normals.row(i) = n.cast<float>();
        mesh.uvs.row(i) = uv.cast<float>();
      }

      for (int i=0; i<num_vertices-2; i++) 
      {
        mesh.vert_indices(i, 0) = 0;
        mesh.vert_indices(i, 1) = i+1;
        mesh.vert_indices(i, 2) = i+2;
      }

      if (must_compute_normal)
        mesh.MakeFlatNormals();
      
      // TODO: This is O(n*n)! Collect all meshes and concatenate them all at once in the end.
      //AddModel(mesh, scope);
      GetScene().Append(mesh, MakeMaterialFromActiveThings(scope));
      continue;
    }
    
    
    /* shader parameters */
    if (!strcmp(token, "shader"))
    {
      char name[LINESIZE];
      int num = std::sscanf(line.c_str(), "shader %s\n", name);
      if(num==1)
      {
        scope.shaders.activate(name);
      }
      else throw MakeException("shader directive needs name of the shader.");
      continue;
    }
   
    
    auto MaybeReadTexture = [this](const char *identifier) -> std::shared_ptr<Texture>
    {
      if (startswith(peek_line, identifier))
      {
        NextLine();
        std::string format = fmt::format("{} %s\n", identifier);
        char buffer [LINESIZE];
        int num = std::sscanf(line.c_str(), format.c_str(), buffer);
        if (num == 1)
        {
          auto path = MakeFullPath(buffer);
          return std::make_unique<Texture>(path);
        }
        else 
          throw MakeException("Error");
      }
      else
        return std::shared_ptr<Texture>(nullptr);
    };
    
    
    if (!strcmp(token,"diffuse"))
    {
      RGB rgb;
      RGBScalar kd;
      char name[LINESIZE];
      int num = std::sscanf(line.c_str(),"diffuse %s %lg %lg %lg %lg\n",name, &rgb[0],&rgb[1],&rgb[2],&kd);
      if (num == 5)
      {
        std::shared_ptr<Texture> diffuse_texture = MaybeReadTexture("diffusetexture");
        InsertAndActivate(name, scope,
          std::make_unique<DiffuseShader>(
            Color::RGBToSpectrum(kd * rgb), std::move(diffuse_texture)));
      }
      else throw MakeException("Error");
      continue;
    }
    
    if (!strcmp(token,"specularreflective"))
    {
      RGB rgb;
      RGBScalar k;
      char name[LINESIZE];
      int num = std::sscanf(line.c_str(),"specularreflective %s %lg %lg %lg %lg\n",name, &rgb[0],&rgb[1],&rgb[2],&k);
      if (num == 5)
      {
        InsertAndActivate(name, scope,
          std::make_unique<SpecularReflectiveShader>(
            Color::RGBToSpectrum(k * rgb)
          ));
      }
      else throw MakeException("Error");
      continue;
    }
    
    if (!strcmp(token, "speculartransmissivedielectric"))
    {
      double ior_ratio = 1.;
      char name[LINESIZE];
      int num = std::sscanf(line.c_str(), "speculartransmissivedielectric %s %lg\n", name, &ior_ratio);
      if (num == 2)
      {
        InsertAndActivate(name, scope,
          std::make_unique<SpecularTransmissiveDielectricShader>(ior_ratio));
      }
      else throw MakeException("Error");
      continue;
    }
    
    if (!strcmp(token, "specularpurerefractive"))
    {
      double ior_ratio = 1.;
      char name[LINESIZE];
      int num = std::sscanf(line.c_str(), "specularpurerefractive %s %lg\n", name, &ior_ratio);
      if (num == 2)
      {
        InsertAndActivate(name, scope,
          std::make_unique<SpecularPureRefractiveShader>(ior_ratio));
      }
      else throw MakeException("Error");
      continue;
    }
    
    
    if (!strcmp(token, "speculardensedielectric"))
    {
      RGB diffuse_coeff;
      double specular_coeff;
      char name[LINESIZE];
      int num = std::sscanf(line.c_str(), "speculardensedielectric %s %lg %lg %lg %lg\n", name, &diffuse_coeff[0], &diffuse_coeff[1], &diffuse_coeff[2], &specular_coeff);
      if (num == 5)
      {
        std::shared_ptr<Texture> diffuse_texture = MaybeReadTexture("diffusetexture");
        InsertAndActivate(name, scope,
          std::make_unique<SpecularDenseDielectricShader>(
            specular_coeff,
            Color::RGBToSpectrum(diffuse_coeff),
            std::move(diffuse_texture)));
      }
      else throw MakeException("Error");
      continue;
    }
    
    if (!strcmp(token,"glossy"))
    {
      RGBScalar k;
      double phong_exponent;
      RGB kd_rgb, ks_rgb;
      char name[LINESIZE];
      
      int num = std::sscanf(line.c_str(),"glossy %s %lg %lg %lg %lg %lg\n",name,&ks_rgb[0], &ks_rgb[1], &ks_rgb[2], &k, &phong_exponent);
      if(num == 6)
      {
        std::shared_ptr<Texture> glossy_texture = MaybeReadTexture("exponenttexture");
        InsertAndActivate(name, scope, 
          std::make_unique<MicrofacetShader>(
            Color::RGBToSpectrum(k*ks_rgb),
            phong_exponent,
            std::move(glossy_texture)));
      }
      else throw MakeException("Error");
      continue;
    }
    
    
    auto MaybeReadPF = [this]() -> std::unique_ptr<PhaseFunctions::PhaseFunction>
    {
      if (startswith(this->peek_line, "pf "))
      {
        this->NextLine();
        double g;
        char name[LINESIZE];
        int num = std::sscanf(this->line.c_str(),"pf %s %lg\n",name, &g);
        if (num > 0)
        {
          if (!strcmp(name, "rayleigh"))
          {
            return std::make_unique<PhaseFunctions::Rayleigh>();
          }
          else if (!strcmp(name, "henleygreenstein") && num>1)
          {
            return std::make_unique<PhaseFunctions::HenleyGreenstein>(g);
          }
        }
        throw MakeException("Error");
      }
      else
        return std::unique_ptr<PhaseFunctions::PhaseFunction>{nullptr};
    };
    
    
    if (!strcmp(token, "medium"))
    {
      RGBScalar buffer[6];
      char name[LINESIZE];
      int num = std::sscanf(line.c_str(), "medium %s %lg %lg %lg %lg %lg %lg\n", name, &buffer[0], &buffer[1], &buffer[2], &buffer[3], &buffer[4], &buffer[5]);
      if(num == 1)
      {
        scope.mediums.activate(name);
      }
      else if(num == 3)
      {
        auto medium = std::make_unique<MonochromaticHomogeneousMedium>(
          value(buffer[0]), 
          value(buffer[1]), 
          scope.mediums.size());
        auto pf = MaybeReadPF();
        if (pf)
          medium->phasefunction = std::move(pf);
        InsertAndActivate(name, scope, std::move(medium));
      }
      else if(num == 7)
      {
        auto medium = std::make_unique<HomogeneousMedium>(
          Color::RGBToSpectrum({buffer[0], buffer[1], buffer[2]}),
          Color::RGBToSpectrum({buffer[3], buffer[4], buffer[5]}), 
          scope.mediums.size());
        auto pf = MaybeReadPF();
        if (pf)
          medium->phasefunction = std::move(pf);
        InsertAndActivate(name, scope, std::move(medium));
      }
      else throw MakeException("Error");
      continue;
    }
    
#if 0
    if (!strcmp(token, "emissivedemomedium"))
    {
      double sigma_s, sigma_a, temperature;
      Double3 pos;
      double radius;
      double extra_emission_multiplier;
      char name[LINESIZE];
      int num = std::sscanf(line.c_str(), "emissivedemomedium %s %lg %lg %lg %lg %lg %lg %lg %lg\n", name, &sigma_s, &sigma_a, &extra_emission_multiplier, &temperature, &pos[0], &pos[1], &pos[2], &radius);
      if (num == 9)
      {
        auto m = std::make_unique<EmissiveDemoMedium>(sigma_s, sigma_a, extra_emission_multiplier, temperature, pos, radius, scope.mediums.size());
        InsertAndActivate(name, scope, std::move(m));
      }
      else throw MakeException("Error");
      continue;
    }
#endif
    
    if (!strcmp(token, "vacuummedium"))
    {
      char name[LINESIZE];
      int num = std::sscanf(line.c_str(), "vacuummedium %s", name);
      if (num == 1)
      {
        auto m = std::make_unique<VacuumMedium>(scope.mediums.size());
        InsertAndActivate(name, scope, std::move(m));
      }
      else throw MakeException("Error");
      continue;
    }


    if (!strcmp(token, "simpleatmosphere"))
    {
      Double3 planet_center;
      double radius;
      char name[LINESIZE];
      int num = std::sscanf(line.c_str(), "simpleatmosphere %s %lg %lg %lg %lg\n", name, &planet_center[0], &planet_center[1], &planet_center[2], &radius);
      if (num==1)
      {
        scope.mediums.activate(name);
      }
      else if(num == 5)
      {
        auto medium = Atmosphere::MakeSimple(planet_center, radius, scope.mediums.size());
        InsertAndActivate(
          name, scope, std::move(medium));
      }
      else
      {
        throw MakeException("Error");
      }
      continue;
    }

    if (!strcmp(token, "tabulatedatmosphere"))
    {
      Double3 planet_center;
      double radius;
      char name[LINESIZE];
      char datafile[LINESIZE];
      int num = std::sscanf(line.c_str(), "tabulatedatmosphere %s %lg %lg %lg %lg %s\n", name, &planet_center[0], &planet_center[1], &planet_center[2], &radius, datafile);
      if (num==1)
      {
        scope.mediums.activate(name);
      }
      else if(num == 6)
      {
        auto full_datafile_path = MakeFullPath(datafile);
        auto medium = Atmosphere::MakeTabulated(planet_center, radius, full_datafile_path.string(), scope.mediums.size());
        InsertAndActivate(
          name, scope, std::move(medium));
      }
      else
      {
        throw MakeException("Error");
      }
      continue;
    }
    
    
    if (!strcmp(token, "lsun"))
    {
      Double3 dir_out;
      double total_power, opening_angle;
      int num = std::sscanf(line.c_str(),"lsun %lg %lg %lg %lg %lg",
          &dir_out[0],&dir_out[1],&dir_out[2], &total_power, &opening_angle);
      Normalize(dir_out);
      if (num == 4)
      {
        // "The Sun is seen from Earth at an average angular diameter of about 9.35×10−3 radians."
        // https://en.wikipedia.org/wiki/Solid_angle
        opening_angle = 0.26;
        num = 5;
      }
      if (num == 5)
      {
        GetScene().envlights.push_back(std::make_unique<Sun>(total_power, dir_out, opening_angle));
      }
      else
      {
        throw MakeException("Error");
      }
      continue;
    }
    
  
    if (!strcmp(token, "lddirection"))
    {
      Double3 dir_out;
      RGB col;
      int num = sscanf(line.c_str(),"lddirection %lg %lg %lg %lg %lg %lg",
          &dir_out[0],&dir_out[1],&dir_out[2],
          &col[0],&col[1],&col[2]);
      Normalize(dir_out);
      if (num == 6)
      {
        GetScene().envlights.push_back(std::make_unique<DistantDirectionalLight>(
          Color::RGBToSpectrum(col), 
          dir_out
        ));
      }
      else
      {
        throw MakeException("Error");
      }
      continue;
    }
  
  
    if (!strcmp(token, "lddome"))
    {
      Double3 dir_up;
      RGB col;
      int num = sscanf(line.c_str(),"lddome %lg %lg %lg %lg %lg %lg",
          &dir_up[0],&dir_up[1],&dir_up[2],
          &col[0],&col[1],&col[2]);
      Normalize(dir_up);
      if (num == 6)
      {
        GetScene().envlights.push_back(std::make_unique<DistantDomeLight>(
          Color::RGBToSpectrum(col), 
          dir_up
        ));
      }
      else
      {
        throw MakeException("Error");
      }
      continue;
    }
  
  
  if (!strcmp(token, "lenv"))
  {
    Double3 dir_up;
    char name[LINESIZE];
    int num = std::sscanf(line.c_str(), "lenv  %lg %lg %lg %s", &dir_up[0], &dir_up[1], &dir_up[2], name);
    if (num == 4)
    {
      auto path = MakeFullPath(name);
      auto tex = std::make_unique<Texture>(path);
      GetScene().envlights.push_back(std::make_unique<EnvMapLight>(tex.get(), dir_up));
      GetScene().textures.push_back(std::move(tex));
    }
    else
      throw MakeException("Error");
    continue;
  }
  
  
  if (!strcmp(token, "larea"))
  {
    char name[LINESIZE];
    char type[LINESIZE];
    int num = std::sscanf(line.c_str(), "larea %s %s", name, type);
    if (num == 1)
    {
      scope.areaemitters.activate(name);
    }
    else if (num == 2)
    {
      if (!strcmp(type, "uniform") || !strcmp(type, "parallel"))
      {
        RGB col;
        double area_power_density;
        char name[LINESIZE];
        int num = std::sscanf(line.c_str(), "larea %s %s %lg %lg %lg %lg",
                              name, type, &col[0], &col[1], &col[2], &area_power_density);
        if (num == 6)
        {
          if (!strcmp(type, "uniform"))
          {
            scope.areaemitters.set_and_activate(
              name, 
              new UniformAreaLight(area_power_density*Color::RGBToSpectrum(col))
            );
          }
          else
          {
            scope.areaemitters.set_and_activate(
              name,
              new ParallelAreaLight(area_power_density*Color::RGBToSpectrum(col))
            );
          }
        }
        else
        {
          throw MakeException("Error");
        }
      }
    }
    else
    {
      throw MakeException("Error");
    }
    continue;
  }
  
    /* lightsource */
  if (!strcmp(token,"l")) 
	{
		Double3 pos;
    RGB col;
    RGBScalar col_multiplier;
		int num = sscanf(line.c_str(),"l %lg %lg %lg %lg %lg %lg %lg",
			   &pos[0],&pos[1],&pos[2],
			   &col[0],&col[1],&col[2], &col_multiplier);
		if (num == 3) {
			// light source with position only
			col = RGB::Constant(1._rgb);
			AddPointLight(std::make_unique<RadianceOrImportance::PointLight>(
        Color::RGBToSpectrum(col),
        pos
      ));
		} else if (num == 7) {
			// light source with position and color
      AddPointLight(std::make_unique<PointLight>(
        Color::RGBToSpectrum(col_multiplier*col),
        pos
      ));	
		} else {
      throw MakeException("Error");
		}
		continue;
    }

	
// 	if(!strcmp(token,"sl"))
// 	{
// 		Double3 pos,dir,col;
// 		double min=0,max=10;
// 		int num = sscanf(line.c_str(),"sl %lg %lg %lg %lg %lg %lg %lg %lg %lg %lg %lg",
// 				&pos[0],&pos[1],&pos[2],&dir[0],&dir[1],&dir[2],&col[0],&col[1],&col[2],&min,&max); 
// 		if(num == 11) {
// 			GetScene().AddLight(std::make_unique<SpotLight>(col,pos,dir,min,max));
// 		}
// 		else {
// 			std::cout << "error in "<<filename<<" : " << line << std::endl;
// 		}
// 		continue;
// 	}
	

  /* include new NFF file */
  if (!strcmp(token,"include"))
  {
    char name[LINESIZE];
    int num = std::sscanf(line.c_str(),"include %s\n", name);
    if (num != 1)
    {
      throw MakeException("Unable to parse include line");
    }
    else
    {
      auto fullpath = MakeFullPath(name);
      std::cout << "including file " << fullpath << std::endl;
      std::ifstream is(fullpath.string());
      if (!is.good())
      {
        throw std::runtime_error(fmt::format("Could not open input file {}", fullpath.string()));
      }
      // Using this scope.
      NFFParser(&GetScene(), GetParams(), is, fullpath).Parse(scope);
    }
    continue;
  }

	
	if (!strcmp(token, "m"))
  {
    char meshfile[LINESIZE];
    int num = sscanf(line.c_str(), "m %s", meshfile);
    if (num == 1)
    {
      auto fullpath = MakeFullPath(meshfile);
      ParseMesh(fullpath.c_str(), scope);
    }
    else
    {
      throw MakeException("Error");
    }
    continue;
  }

    throw MakeException("Unkown directive");
  }
};


void NFFParser::ParseYaml(const std::string& yaml_section_str, Scope& scope)
{
  std::cout << "Parse YAML:\n--------\n" << yaml_section_str << "\n-------\n" << std::flush;
  YAML::Node doc = YAML::Load(yaml_section_str);
  /* Example: Transform
   * transform:
   *   pos: [x, y, z]
   *   hpb: [ h, p, b ]
   *   rotaxis: [ x, y, z]
   *   scale: [x, y, z]
   *   angle_in_degree
   * 
   * shader:
   *   class: ...
   *   name: ...
   *   param1: ....
   *   param2: ....
   * 
   * medium:
   *   name: ...
   *   priority: 1
   *   param1: ....
   *   param2: ....
   * 
   * material: ...
   *   shader: myshader
   *   medium: mymedium
   *   emissive: myarealight
   */
  for(YAML::const_iterator it = doc.begin(); it!=doc.end(); ++it)
  {
    ParseYamlNode(it->first.as<std::string>(), it->second, scope);
  }
}


void NFFParser::ParseYamlNode(const std::string &key, const YAML::Node &node, Scope &scope)
{
  if (key == "transform")
  {
    auto trafo = decltype(scope.currentTransform)::Identity();
    auto pos_node   = node["pos"];
    auto hpb_node   = node["hpb"];
    auto scale_node = node["scale"];
    auto rotaxis_node = node["rotaxis"];
    if (pos_node)
    {
      trafo = Eigen::Translation3d(pos_node.as<Double3>());
    }
    if (hpb_node)
    {
      auto r = hpb_node.as<Double3>();
      if (node["angle_in_degree"] && node["angle_in_degree"].as<bool>())
        r *= Pi/180.;
      // The heading, pitch, bank convention assuming Y is up and Z is forward!
      trafo = trafo *
        Eigen::AngleAxisd(r[0], Eigen::Vector3d::UnitY()) *
        Eigen::AngleAxisd(r[1], Eigen::Vector3d::UnitX()) *
        Eigen::AngleAxisd(r[2], Eigen::Vector3d::UnitZ());
    }
    if (rotaxis_node)
    {
      auto r = rotaxis_node.as<Double3>();
      if (node["angle_in_degree"] && node["angle_in_degree"].as<bool>())
        r *= Pi/180.;
      trafo = trafo * Eigen::AngleAxisd(r.norm(), r.normalized());
    }
    if (scale_node)
    {
      auto s = scale_node.as<Double3>();
      trafo = trafo * Eigen::Scaling(s);
    }
    scope.currentTransform = trafo;
    std::cout << "Transform: t=\n" << scope.currentTransform.translation() << "\nr=\n" << scope.currentTransform.linear() << std::endl;
  }
  else if (key == "shader")
  {
    auto class_ = node["class"].as<std::string>();
    auto name = node["name"].as<std::string>();
    if (class_ == "speculartransmissivedielectric")
    {
      auto ior_ratio = node["ior_ratio"].as<double>();
      auto abbe_node = node["abbe_number"];
      double ior_coeff = 0.;
      if (abbe_node)
      {
        double v = abbe_node.as<double>();
        // https://en.wikipedia.org/wiki/Abbe_number
        // v = (n(589)-1) / (n(486) - n(656))
        // Assuming that ior_ratio is the number for lambda=589nm.
        ior_coeff = (ior_ratio-1)/v/(656-486); 
      }
      auto shd = std::make_unique<SpecularTransmissiveDielectricShader>(ior_ratio, ior_coeff);
      InsertAndActivate(name.c_str(), scope, std::move(shd));
    }
    else if (class_ == "glossytransmissivedielectric")
    {
      auto ior_ratio = node["ior_ratio"].as<double>();
      auto alpha = node["alpha"].as<double>();
      auto texture_node = node["alpha_texture"];
      std::shared_ptr<Texture> texture;
      double alpha_min = 0.;
      if (texture_node)
      {
        auto path = MakeFullPath(texture_node.as<std::string>());
        texture = std::make_shared<Texture>(path);
        alpha_min = node["alpha_min"].as<double>();
      }
      auto shd = MakeGlossyTransmissiveDielectricShader(ior_ratio, alpha, alpha_min, texture);
      InsertAndActivate(name.c_str(), scope, std::move(shd));
    }
    else if (class_ == "glossy")
    {
      auto alpha = node["alpha"].as<double>();
      auto texture_node = node["alpha_texture"];
      std::shared_ptr<Texture> texture;
      if (texture_node)
      {
        auto path = MakeFullPath(texture_node.as<std::string>());
        texture = std::make_shared<Texture>(path);
      }
      RGB ks_rgb{1._rgb};
      RGBScalar k{1._rgb};
      if (node["rgb"])
      {
        auto tmp = node["rgb"].as<Double3>();
        ks_rgb = RGB{RGBScalar{tmp[0]},RGBScalar{tmp[1]},RGBScalar{tmp[2]}};
      }
      if (node["x"])
        k = RGBScalar{node["x"].as<double>()};
      auto shd = std::make_unique<MicrofacetShader>(Color::RGBToSpectrum(k*ks_rgb), alpha, texture);
      InsertAndActivate(name.c_str(), scope, std::move(shd));
    }
    else
      throw MakeException(fmt::format("Unkown shader class in yaml: {}", class_));

    if (scope.shaders() && node["prefer_path_tracing"])
      scope.shaders()->prefer_path_tracing_over_photonmap = node["prefer_path_tracing"].as<bool>();
  }
  else if (key == "material")
  {
    auto name = node["name"].as<std::string>();
    AddNamedMaterialFromActiveThings(name, scope);
  }
}


void NFFParser::ParseMesh(const fs::path &filename, Scope &original_scope)
{
  Scope scope{ original_scope }; // Because item activations may change?
  auto material_getter = [&](const std::optional<std::string> &name) -> Material {
    return GetMaterial(scope, name);
  };
  assimp::Read(GetScene(), scope.currentTransform, material_getter, false, filename);
}


void Scene::ParseNFF(const fs::path &filename, RenderingParameters *render_params)
{
  std::ifstream is(filename.string());
  if (!is.good())
  {
    throw std::runtime_error(fmt::format("Could not open input file {}", filename.string()));
  }
  NFFParser parser(this, render_params, is, filename);
  Scope scope;
  AddDefaultMaterials(scope, *this);
  parser.Parse(scope);
  envlight = std::make_unique<TotalEnvironmentalRadianceField>(this->envlights);
}


void Scene::ParseNFFString(const std::string &scenestr, RenderingParameters *render_params)
{
  std::istringstream is(scenestr);
  ParseNFF(is, render_params);
}


void Scene::ParseNFF(std::istream &is, RenderingParameters *render_params)
{
  NFFParser parser(this, render_params, is, std::string());
  Scope scope;
  AddDefaultMaterials(scope, *this);
  parser.Parse(scope);
  envlight = std::make_unique<TotalEnvironmentalRadianceField>(this->envlights);
}


bool NFFParser::NextLine()
{
  line = peek_line;
  line_stream_state = peek_stream_state;
  ++lineno;
  peek_stream_state = (bool)std::getline(input, peek_line);
  return line_stream_state;
}



//void NFFParser::AddModel(const Mesh &m, const Scope &scope)
//{
//  GetScene().Append(m);
//}


void NFFParser::InsertAndActivate(const char* name, Scope& scope, std::unique_ptr< Medium > x)
{
  scope.mediums.set_and_activate(name, x.get());
  GetScene().media.emplace_back(std::move(x));
}


void NFFParser::InsertAndActivate(const char* name, Scope& scope, std::unique_ptr< Shader > x)
{
  scope.shaders.set_and_activate(name, x.get());
  GetScene().shaders.emplace_back(std::move(x));
}


//MaterialIndex NFFParser::GetMaterialIndexOfCurrentParams(const Scope &scope)
//{
//  return MaterialInsertAndOrGetIndex(MakeMaterialFromActiveThings(scope));
//}

fs::path NFFParser::MakeFullPath(const fs::path &filename) const
{
  try {
    return GlobalContext::MakeFullPath(filename);
  }
  catch(const std::runtime_error &e)
  {
    throw MakeException(e.what());
  }
}


std::runtime_error NFFParser::MakeException(const std::string &msg) const
{
  std::stringstream os;
  if (!GetFilename().empty())
    os << GetFilename() << ":";
  os << lineno << ": " << msg << " [" << line << "]";
  return std::runtime_error(os.str());
}


void NFFParser::AddPointLight(std::unique_ptr<RadianceOrImportance::PointEmitter> p)
{
  p->scene_index = isize(GetScene().lights);
  GetScene().lights.push_back(std::move(p));
}