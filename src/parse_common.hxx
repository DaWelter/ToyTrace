#pragma once
#include "scene.hxx"
#include "camera.hxx"
//#include "infiniteplane.hxx"
#include "shader.hxx"
#include "util.hxx"
#include "light.hxx"

#include <vector>
#include <cstdio>
#include <iostream>
#include <fstream>
#include <unordered_map>

#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>


#ifdef _MSC_VER
// Warnings generated by yaml-cpp. Hopefully they are harmless. They don't look like it ... :-/
#pragma warning (disable: 4251)
#pragma warning (disable: 4373)
#pragma warning (disable: 4275)
#endif
#include <yaml-cpp/yaml.h>


namespace scenereader
{

using RadianceOrImportance::AreaEmitter;

namespace fs = boost::filesystem;

using Transform = Eigen::Transform<double, 3, Eigen::Affine>;

// TODO: Rename this
template<class Thing>
class SymbolTable
{
  Thing currentThing;
  std::unordered_map<std::string, Thing> things;
  std::string name_of_this_table;
public:
  SymbolTable(const std::string &_name) :
    currentThing{}, name_of_this_table(_name)
  {}

  int size() const
  {
    return isize(things);
  }

  const auto& name() const { return name_of_this_table;  }

  void activate(const std::string &name)
  {
    auto it = things.find(name);
    if (it != things.end())
    {
      currentThing = it->second;
    }
    else
    {
      char buffer[1024];
      std::snprintf(buffer, 1024, "Error: %s %s not defined. Define it in the NFF file prior to referencing it.", this->name_of_this_table.c_str(), name.c_str());
      throw std::runtime_error(buffer);
    }
  }

  void set_and_activate(const char* name, Thing thing)
  {
    currentThing = thing;
    things[name] = thing;
  }

  Thing operator()() const
  {
    return currentThing;
  }

  std::optional<Thing> operator[](const char *name) const
  {
    auto it = things.find(name);
    if (it == things.end())
      return {};
    else
      return it->second;
  }

  std::optional<Thing> operator[](const std::string &name) const
  {
    return this->operator[](name.c_str());
  }
};


class GlobalContext
{
  std::unordered_map<Material, MaterialIndex, Material::Hash> to_material_index;
  std::vector<fs::path> search_paths;
  Scene* scene;
  RenderingParameters* params;
  fs::path filename;

public:
  GlobalContext(Scene &scene_, RenderingParameters *params_, const fs::path &path_hint);
  auto& GetScene() const { return *scene; }
  auto* GetParams() const { return params; }
  auto GetFilename() const { return filename; }
  fs::path MakeFullPath(const fs::path &filename) const;
};


struct Scope
{
  SymbolTable<Shader*> shaders;
  SymbolTable<Medium*> mediums;
  SymbolTable<AreaEmitter*> areaemitters;
  std::unordered_map<std::string, Material> materials;
  Transform currentTransform;

  Scope() :
    shaders("Shader"),
    mediums("Medium"),
    areaemitters("AreaEmitter"),
    currentTransform{ Transform::Identity() }
  {
  }

  void InsertAndActivate(const std::string& name, Shader* item) { shaders.set_and_activate(name.c_str(), item); }
  void InsertAndActivate(const std::string& name, Medium* item) { mediums.set_and_activate(name.c_str(), item); }
  void InsertAndActivate(const std::string& name, AreaEmitter* item) { areaemitters.set_and_activate(name.c_str(), item); }
  template<class U>
  inline auto Lookup(const std::string &key) const;
};

template<>
inline auto Scope::Lookup<Shader>(const std::string &key) const { return shaders[key.c_str()]; }
template<>
inline auto Scope::Lookup<Medium>(const std::string &key) const { return mediums[key.c_str()]; }
template<>
inline auto Scope::Lookup<AreaEmitter>(const std::string &key) const { return areaemitters[key.c_str()]; }


void AddDefaultMaterials(Scope &scope, const Scene &scene);


inline auto NormalTrafo(const Transform &trafo)
{
  return trafo.linear().inverse().transpose().eval();
}



namespace assimp
{

using MaterialGetter = std::function<Material(const std::optional<std::string> &)>;

void Read(Scene &scene, Transform model_transform, MaterialGetter material_getter, bool material_assignment_by_object_names, const fs::path &filename_path);


} // namespace assimp

} // namespace scenereader



namespace YAML 
{

// Adapted from https://github.com/jbeder/yaml-cpp/wiki/Tutorial
template<>
struct convert<Double3> {
  static bool decode(const Node& node, Double3& rhs) {
    if (!node.IsSequence() || node.size() != 3) {
      return false;
    }
    rhs[0] = node[0].as<double>();
    rhs[1] = node[1].as<double>();
    rhs[2] = node[2].as<double>();
    return true;
  }
};


template<>
struct convert<RGB> {
  static bool decode(const Node& node, RGB& rhs) {
    if (!node.IsSequence() || (node.size() != 3 && node.size() != 1)) {
      return false;
    }
    rhs[0] = RGBScalar{ node[0].as<double>() };
    if (node.size() == 3)
    {
      rhs[1] = RGBScalar{ node[1].as<double>() };
      rhs[2] = RGBScalar{ node[2].as<double>() };
    }
    else
    {
      rhs[1] = rhs[2] = rhs[0];
    }
    return true;
  }
};


}